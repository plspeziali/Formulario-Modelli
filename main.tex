\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage[landscape,margin=1cm]{geometry}
\usepackage[italian]{babel}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsfonts} 

\usepackage{xparse}

\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{black}{#1}}%
}

\lstset{language=C,keywordstyle={\bfseries \color{black}}}


% colour themes to come. KnitR?

%-------------------------

\title{Formulario di Modelli di Calcolo e Algoritmi Avanzati}
\author{Paolo Speziali}
\date{Giugno 2022}
\input{cheatsheet-template.tex}

\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000


%--------------------------------------------------------------------------------
\begin{document}
\small
\begin{multicols}{3}

\maketitle
\thispagestyle{empty}


\section{Linguaggi e grammatiche}


\begin{textbox}{Tipi di grammatiche}

\red{Tipo 0}
Detta anche \textbf{non limitata}, ammette \textbf{qualunque tipo}
di produzione, anche quelle che accorciano le forme di
frase, come ad esempio quelle che si ottengono da \(\varepsilon\)-produzioni
(es. \(aA\,\rightarrow\,b\,|\,\varepsilon\)).

\red{Tipo 1}
Detta anche \textbf{context-sensitive}, ammette \textbf{qualunque tipo}
di produzione che \textbf{non accorci} le forme di frase
(es. \(aA\,\rightarrow\,Bb\)).

\red{Tipo 2}
Detta anche \textbf{context-free}, ammette produzioni in cui
il termine sinistro è formato da un solo non terminale
e la forma di frase non si accorcia mai \\
(es. \(A\,\rightarrow\,aBb\)).

\red{Tipo 3}
Detta anche \textbf{regolare}, ammette produzioni in cui
il termine sinistro è formato da un solo non terminale
e il termine destro o da un solo terminale o da un
terminale seguito da un non terminale\\
(es. \(aA\,\rightarrow\,b\,|\,aB\)).

\end{textbox}


\begin{textbox}{Pumping Lemma per L. Regolari}
Se L è un linguaggio regolare allora \\
\(\exists \, n \, > \, 0\) tale che \(\forall \, z \, \in \, L \) e
\(|z| \, \geq \, n\),\\si ha che
\(\exists \, u \, ,v \, ,w\) tali che:
\begin{enumerate}[leftmargin=*]
    \item \(z\, =\, uvw\)
    \item \(|uv|\, \leq\,  n\)
    \item \(|v|\, \geq\,  1\)
    \item \(uv^iw\,\in\,L,\,\forall\,i\,\geq\,0\)
\end{enumerate}

\end{textbox}

\begin{textbox}{Da Gram. Reg. a Esp. Reg.}
Dal sistema di equazioni lineari si ricava una espressione regolare
applicando le due tecniche seguenti ripetutamente:
\begin{itemize}[leftmargin=*]
    \item \textbf{Sostituzione}: si può sostituire un simbolo non terminale con una espressione equivalente \\
    (es. \(A\, aB\, +\, b,\, B\, =\, cA\,\Rightarrow \,  =\, acA\, +\, b)\)
    \item \textbf{Eliminazione della ricorsione}: si può sostituire la prima equazione con la seconda\\
    \(A\,=\,\alpha_1A\,+\,\alpha_2A\,+\,...\,+\
    \alpha_nA\,+\,\beta_1\,+\,\beta_2\,+\,...\,+\
    \beta_n\) \\
    \(A\,=\,(\alpha_1\,+\,\alpha_2\,+\,...\,+\
    \alpha_n\,)^\ast(\beta_1\,+\,\beta_2\,+\,...\,+\
    \beta_n)\)
\end{itemize}

\end{textbox}


\begin{textbox}{Dimostrazione regolarità linguaggio}
\lipsum[1]

\end{textbox}

\begin{textbox}{Forma ridotta}
Una grammatica G CF è in forma ridotta se:
\begin{itemize}[leftmargin=*]
    \item G non contiene \(\varepsilon\)-produzioni
    se non sull’assioma, ed in tal caso l’assioma non
    compare a destra di nessuna produzione;
    \item G non contiene simboli inutili, cioè non fecondi o non generabili;
    \item G non contiene produzioni unitarie\\(cioè del tipo \(A\,\rightarrow\,B\)).
\end{itemize}

\end{textbox}

\begin{textbox}{Forma normale di Chomsky (CNF)}
Una grammatica G CF è in CNF se tutte le sue produzioni sono del tipo \(A\,\rightarrow\,BC\) o \(A\,\rightarrow\,a\).\\
Per arrivarci si porta G in forma ridotta e si sostituisce ogni terminale \(a\) con un non terminale \(X_a\) in tutte le produzioni
in cui compare \(a\) ed si introduce la produzione \(X_a\,\rightarrow\,a\)
(la forma ottenuta a questo punto si chiama \textbf{quasi CFN}).\\
Infine si sotituisce ricorsivamente ogni produzione del tipo:\\
\(A\,\rightarrow\,BC\alpha\) con le seguenti:
\(A\,\rightarrow\,BD\), \(D\,\rightarrow\,C\alpha\) dove D è un nuovo non terminale.
\end{textbox}


\begin{textbox}{Forma normale di Greibach (GNF)}
Una grammatica G CF è in GNF se tutte le sue produzioni sono del tipo \(A\,\rightarrow\,a\beta\), dove \(\beta\) è una sequenza (eventualmente vuota) di non terminali e \(a\)  è un simbolo terminale.
\end{textbox}

\begin{textbox}{Pumping Lemma per L CF}
Se L è un linguaggio CF allora \\
\(\exists \, n \, > \, 0\) tale che \(\forall \, z \, \in \, L \) e
\(|z| \, \geq \, n\),\\si ha che
\(\exists \, u \, ,v \, ,w \, ,x \, ,y\) tali che:
\begin{enumerate}[leftmargin=*]
    \item \(z\, =\, uvwxy\)
    \item \(|vwx|\, \leq\,  n\)
    \item \(|vx|\, \geq\,  1\)
    \item \(uv^iwx^iy\,\in\,L,\,\forall\,i\,\geq\,0\)
\end{enumerate}
\end{textbox}


%--------------------------------------------------------------
\section{Macchine a Registri}

\begin{textbox}{Istruzioni di trasferimento}
\begin{itemize}[leftmargin=*]
    \item \textbf{LOAD} <op>\quad(\codeword{R[0] := <op>});
    \item \textbf{STORE} <op>\quad(\codeword{R[<op>] := R[0]}).
\end{itemize}
\end{textbox}

\begin{textbox}{Istruzioni aritmetiche}
\begin{itemize}[leftmargin=*]
    \item \textbf{ADD} <op>\quad(\codeword{R[0] := R[0] + <op>});
    \item \textbf{SUB} <op>\quad(\codeword{R[0] := R[0] - <op>});
    \item \textbf{MULT} <op>\quad(\codeword{R[0] := R[0] * <op>});
    \item \textbf{DIV} <op>\quad(\codeword{R[0] := R[0] / <op>}).
\end{itemize}
\end{textbox}

\begin{textbox}{Istruzioni di I/O}
\begin{itemize}[leftmargin=*]
    \item \textbf{READ} <op>\quad(\codeword{R[<op>] := IN});
    \item \textbf{WRITE} <op>\quad(\codeword{OUT := <op>}).
\end{itemize}
\end{textbox}

\begin{textbox}{Istruzioni di salto e di controllo}
\begin{itemize}[leftmargin=*]
    \item \textbf{JUMP} <et>\quad(\codeword{CI := <et>});
    \item \textbf{JGTZ} <et>\quad(\codeword{if (R[0] > 0) then CI := <et> else CI := CI + 1});
    \item \textbf{JZERO} <et>\quad(\codeword{if (R[0] = 0) then CI := <et> else CI := CI + 1});
    \item \textbf{HALT}\quad(\codeword{fine, il calcolo si arresta}).
\end{itemize}
\end{textbox}

\begin{textbox}{Operandi ed etichette}
Ogni operando \codeword{<op>} può avere una delle forme seguenti:
\begin{itemize}[leftmargin=*]
    \item \textbf{n}: \codeword{<op>} indica l’intero memorizzato nel registro n;
    \item \textbf{(n)}: \codeword{<op>} indica l’intero memorizzato nel registro indirizzato dal
    registro n;
    \item \textbf{\#n}: \codeword{<op>} indica il numero n.
\end{itemize}
Ogni etichetta \codeword{<et>} ha la forma \textbf{n}, ed indica il numero intero n.
\end{textbox}

\section{Complessità}

\begin{textbox}{Tipologie di problemi}
Per definire le varie tipologie di problemi useremo degli esempi che
partono dal concetto di \textbf{Clique}.\\

\begin{textbox}{Problemi di decisione}
Un problema di decisione \(P_D\) è definito da:
\begin{itemize}[leftmargin=*]
    \item Un insieme di istanze \(I_{P_D}\);
    \item Un predicato \(\pi\): \(I_{P_D} \rightarrow\) \{vero, falso\}.
\end{itemize}

\codeword{CLIQUE}\\
\codeword{Istanza}: Grafo \(G\), intero \(K > 0\) \\
\codeword{Predicato}: Esiste una clique di \(G\) di dimensione \(\geq\) K ?

\end{textbox}

\begin{textbox}{Problemi di ricerca}
Un problema di decisione \(P_R\) è definito da:
\begin{itemize}[leftmargin=*]
    \item Un insieme di istanze \(I_{P_R}\);
    \item Un insieme di soluzioni candidate  \(S_{P_R}\);
    \item Una proprietà di ammissibilità che deve valere per ogni soluzione di una
    data istanza.
\end{itemize}

\codeword{RICERCA CLIQUE}\\
\codeword{Istanza}: Grafo \(G\), intero \(K > 0\) \\
\codeword{Soluzione candidata}: Sottoinsieme \(V'\) di vertici \\
\codeword{Ammissibilità}: \(V'\) è una clique di \(G\) di dimensione \(\geq\) K

Un algoritmo che lo risolve prende in input una
istanza \(x\) e restituisce (se esiste) un elemento di\\
\(Sol(x)\) = \{ \(y\,\in\,S_{P_R}\) : \(y\) rispetta la proprietà di ammissibilità \}.

\end{textbox}

\end{textbox}

\begin{textbox}{Tipologie di problemi}

Ogni problema di ricerca \(P_R\) ha un problema di decisione associato \(P_D\).\\

\begin{textbox}{Problemi di enumerazione}
Un problema di decisione \(P_E\) è definito da:
\begin{itemize}[leftmargin=*]
    \item Un insieme di istanze \(I_{P_E}\);
    \item Un insieme di soluzioni candidate  \(S_{P_E}\);
    \item Una proprietà di ammissibilità.
\end{itemize}
Un algoritmo che lo risolve prende in input una istanza \(x\)  e
restituisce la cardinalità dell’insieme \(Sol(x)\).
\end{textbox}

\begin{textbox}{Problemi di ottimizzazione}
Un problema di decisione \(P_E\) è definito da:
\begin{itemize}[leftmargin=*]
    \item Un insieme di istanze \(I_{P_O}\), un insieme di soluzioni candidate  \(S{P_O}\), ed una proprietà di ammissibilità;
    \item Una funzione di misura \\\(\mu:\,I_{P_O}\,\times S_{P_O}\,\rightarrow\,\mathbb{N} \)
    definita solo sulle coppie \((x,y)\) tali che \(y\,\in\,Sol(x)\);
    \item Un criterio di scelta \(c\,\in\,\)\{MIN, MAX\};
\end{itemize}
Un algoritmo che lo risolve prende
una istanza \(x\) e restituisce \(y\) tale
che,\\ \(\forall\,z\,\in\,Sol(x)\), \\
\(m(x,y) \leq m(x,z)\) se \(c\) = MIN e \\
\(m(x,y) \geq m(x,z)\) se \(c\) = MAX.\\
\codeword{RICERCA CLIQUE}\\
\codeword{Istanza}: Grafo \(G\)\\
\codeword{Soluzione candidata}: Insieme \(V'\) di vertici \\
\codeword{Ammissibilità}: \(V'\) è una clique di \(G\)\\
\codeword{Misura}: \(|V'|\) \\
\codeword{Criterio}: MAX
\end{textbox}


\end{textbox}


%\begin{textbox}{Subboxes}
%---------------------------------------------
%\begin{multibox}{2} % number of boxes in a row
%\begin{subbox}{subbox}{test}

%\red{test} 
%\bggreen{test}
%\href{https://latex-ninja.com}{Link}
%\end{subbox}
%\begin{subbox}{customcolor}{test}
%\scriptsize


%\bggreen{test}
%\tiny
%super small font

%\mycommand{$\land$}{AND $\land$}
%\mycommand{$\lor$}{OR $\lor$}
%\end{subbox}
%\end{multibox}

%---------------------------------------------
%\begin{multibox}{2} % number of boxes in a row
%\begin{subbox}{subbox}{ Info}
%
%\red{bla}\\
%\bggreen{XX}\\

%\end{subbox}
%\begin{subbox}{customcolor}{Info}
%
%\end{subbox}
%\end{multibox}
%\end{textbox}

%---------------------------------------------
\end{multicols}

\end{document}
